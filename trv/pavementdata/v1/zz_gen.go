// Package v1 contains the type definitions for PavementData v1.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1

import (
	"encoding/xml"
	"strings"
	"time"

	schema "code.dny.dev/trafikinfo/internal/trv/pavementdata/v1"
	"code.dny.dev/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func ObjectType() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "PavementData",
		Version:   "1",
		Namespace: "",
	}
}

type PavementData struct {
	data *schema.PavementData
}

func (x *PavementData) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.PavementData{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Län.
func (x *PavementData) County() int {
	return x.data.County
}

// SV: Huvudvägnummer.
func (x *PavementData) RoadMainNumber() int {
	return x.data.RoadMainNumber
}

// SV: Undervägnummer. Kallas ibland även punktväg. Måste användas ihop med huvudvägnumret.
func (x *PavementData) RoadSubNumber() int {
	return x.data.RoadSubNumber
}

func (x *PavementData) Direction() *Direction {
	return &Direction{data: x.data.Direction}
}

// SV: Körfält. Räknas från höger sida och startar med körfält 10. Nästa är 20 och kan gå upp till 50.
func (x *PavementData) Lane() int {
	return x.data.Lane
}

// SV: Start löpande längd. Anges i meter. Starten för aktuell åtgärdsinformation angivet i antal meter från vägnumrets start inom det länet, i aktuell riktning.
func (x *PavementData) StartContinuousLength() int {
	return x.data.StartContinuousLength
}

// SV: Slut löpande längd. Anges i meter. Slutet för aktuell åtgärdsinformation angivet i antal meter från vägnumrets start inom det länet, i aktuell riktning.
func (x *PavementData) EndContinuousLength() int {
	return x.data.EndContinuousLength
}

// SV: Längd i antal meter
func (x *PavementData) Length() int {
	return x.data.Length
}

// SV: Beläggningsdatum. Datum när åtgärd utfördes. (om flera åtgärder på samma sträcka anges senaste datumet)
func (x *PavementData) PavementDate() time.Time {
	return x.data.PavementDate
}

// SV: Typ av åtgärd.
func (x *PavementData) PavementType() *string {
	return x.data.PavementType
}

// SV: Åtgärdskategori. Gruppering av åtgärder som är av liknande karaktär.
func (x *PavementData) TreatmentCategory() *string {
	return x.data.TreatmentCategory
}

// SV: Stenstorlek i beläggningen.
func (x *PavementData) MaxStoneSize() int {
	return x.data.MaxStoneSize
}

// SV: Tjocklek. Medelvärde för beläggningsåtgärdens tjocklek.
func (x *PavementData) Thickness() float64 {
	return x.data.Thickness
}

// SV: Entreprenör. Den som utfört åtgärden.
func (x *PavementData) Contractor() *string {
	return x.data.Contractor
}

// SV: Kulkvarnsvärde som är aktuell i beläggningsåtgärden.
func (x *PavementData) BallMillValue() float64 {
	return x.data.BallMillValue
}

// SV: Bindemedel som är aktuellt i beläggningen.
func (x *PavementData) Binder() *string {
	return x.data.Binder
}

// SV: Tillverkningsmetod som använts för beläggningen.
func (x *PavementData) ManufacturingMethod() *string {
	return x.data.ManufacturingMethod
}

// SV: Utläggningsmetod.
func (x *PavementData) PavingMethod() *string {
	return x.data.PavingMethod
}

// SV: Täckning. I vilken utsträckning åtgärden omfattar hela längden angiven för åtgärden eller bredden på körfältet.
func (x *PavementData) Coverage() *string {
	return x.data.Coverage
}

// SV: Garantitid. Det antal år som garantitiden gäller för utförd åtgärd.
func (x *PavementData) Warranty() int {
	return x.data.Warranty
}

// SV: Garantitid förfaller år. Datum då garantin för åtgärden förfaller.
func (x *PavementData) WarrantyIsDue() time.Time {
	return x.data.WarrantyIsDue
}

// SV: Datum för besiktningen av åtgärden.
func (x *PavementData) FinalInspectionDate() time.Time {
	return x.data.FinalInspectionDate
}

// SV: Datum för när NVDB-data och beläggningsdata hämtades ut från källsystemen.
func (x *PavementData) TimeStamp() time.Time {
	return x.data.TimeStamp
}

// SV: Tidpunkt då dataposten ändrades
// EN: Time when the data item was changed
func (x *PavementData) ModifiedTime() *time.Time {
	return x.data.ModifiedTime
}

// SV: Anger att dataposten raderats
// EN: Indicates that the data record has been deleted
func (x *PavementData) Deleted() *bool {
	return x.data.Deleted
}

type Direction struct {
	data *schema.Direction
}

func (x *Direction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Direction{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Riktning. Värde.
func (x *Direction) Code() int {
	return x.data.Code
}

// SV: Riktning. Beskrivning.
func (x *Direction) Value() *string {
	return x.data.Value
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "code.dny.dev/trafikinfo/trv/pavementdata/v1"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError  `xml:"ERROR"`
		Data  []PavementData `xml:"PavementData"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
