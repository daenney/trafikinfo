// Package v1dot9 contains the type definitions for TrainAnnouncement v1.9.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1dot9

import (
	"encoding/xml"
	"strings"
	"time"

	schema "code.dny.dev/trafikinfo/internal/trv/trainannouncement/v1dot9"
	"code.dny.dev/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func ObjectType() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "TrainAnnouncement",
		Version:   "1.9",
		Namespace: "",
	}
}

type TrainAnnouncement struct {
	data *schema.TrainAnnouncement
}

func (x *TrainAnnouncement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TrainAnnouncement{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Aktivitetens unika id
func (x *TrainAnnouncement) ActivityID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.ActivityId
}

// SV: "Ankomst" eller "Avgang"
func (x *TrainAnnouncement) ActivityType() *string {
	if x.data == nil {
		return nil
	}
	return x.data.ActivityType
}

// SV: Anger om ankomsten/avgången annonseras i tidtabell
func (x *TrainAnnouncement) Advertised() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Advertised
}

// SV: Tidtabellstid
func (x *TrainAnnouncement) AdvertisedTimeAtLocation() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.AdvertisedTimeAtLocation
}

// SV: Annonserat tågnummer (tågnumret som står på biljetten)
func (x *TrainAnnouncement) AdvertisedTrainIdent() *string {
	if x.data == nil {
		return nil
	}
	return x.data.AdvertisedTrainIdent
}

// SV: Kod för bokningsinformation och bokningsinformation, ex: "Vagn 4 obokad
func (x *TrainAnnouncement) Bookings() []Booking {
	data := []Booking{}
	for _, mem := range x.data.Booking {
		data = append(data, Booking{data: &mem})
	}
	return data
}

// SV: Anger om ankomsten/avgången är inställd
func (x *TrainAnnouncement) Canceled() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Canceled
}

// SV: Anger att dataposten raderats
func (x *TrainAnnouncement) Deleted() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Deleted
}

// SV: Utgångsdatum för det Operativa tågnumret.
func (x *TrainAnnouncement) DepartureDateOTN() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.DepartureDateOTN
}

// SV: Eventuell avvikelse med full orsakskod, ex: ABC023 och beskrivning, ex: "Buss ersätter", "Spårändrat", "Kort tåg", "Ej servering" o.s.v.
func (x *TrainAnnouncement) Deviations() []Deviation {
	data := []Deviation{}
	for _, mem := range x.data.Deviation {
		data = append(data, Deviation{data: &mem})
	}
	return data
}

// SV: Tidpunkt för beräknad ankomst eller avgång
func (x *TrainAnnouncement) EstimatedTimeAtLocation() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.EstimatedTimeAtLocation
}

// SV: Anger om en beräknad tid är preliminär. Notera att om den beräknade tiden är preliminär så innebär det att den kan ändras både framåt och bakåt, ett tåg kan alltså t.ex avgå tidigare än beräknad tidpunkt om den också är markerad som preliminär.
func (x *TrainAnnouncement) EstimatedTimeIsPreliminary() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.EstimatedTimeIsPreliminary
}

// SV: Från station för tåget med ordning och i vilken prioritet som ska visas. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. FromLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur från-stationer ska annonseras.
func (x *TrainAnnouncement) FromLocations() []FromLocation {
	data := []FromLocation{}
	for _, mem := range x.data.FromLocation {
		data = append(data, FromLocation{data: &mem})
	}
	return data
}

// SV: Namnet på trafikinformationsägaren
func (x *TrainAnnouncement) InformationOwner() *string {
	if x.data == nil {
		return nil
	}
	return x.data.InformationOwner
}

// SV: Det operativa tågets ankomst- eller avgångstid enligt tidtabell (kan skilja sig från den annonserade tiden).
func (x *TrainAnnouncement) LocationDateTimeOTN() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.LocationDateTimeOTN
}

// SV: Signatur för stationen
func (x *TrainAnnouncement) LocationSignature() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationSignature
}

// SV: Url till trafikägarens mobila hemsida
func (x *TrainAnnouncement) MobileWebLink() *string {
	if x.data == nil {
		return nil
	}
	return x.data.MobileWebLink
}

// SV: Tidpunkt då dataposten ändrades
func (x *TrainAnnouncement) ModifiedTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ModifiedTime
}

// SV: Anger i vilken ordning tåget nyutrustats. Om ingen nyutrustning skett kommer värdet vara noll
func (x *TrainAnnouncement) NewEquipment() *int {
	if x.data == nil {
		return nil
	}
	return x.data.NewEquipment
}

// SV: Det järnvägsföretag som utför järnvägstrafik, alltså kör tåget, för en trafikorganisatör.
func (x *TrainAnnouncement) Operator() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Operator
}

// SV: Operativt tågnummer (OTN).
func (x *TrainAnnouncement) OperationalTrainNumber() *string {
	if x.data == nil {
		return nil
	}
	return x.data.OperationalTrainNumber
}

// SV: Kod för övrig annonseringsinformation och övrig annonseringsinformation, ex. "Trevlig resa!", "Bakre fordon går låst!", "Ingen påstigning"
func (x *TrainAnnouncement) OtherInformation() []OtherInformation {
	data := []OtherInformation{}
	for _, mem := range x.data.OtherInformation {
		data = append(data, OtherInformation{data: &mem})
	}
	return data
}

// SV: Anger en planerad försening och dess giltighet anges med PlannedEstimatedTimeAtLocationIsValid-flaggan
func (x *TrainAnnouncement) PlannedEstimatedTimeAtLocation() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.PlannedEstimatedTimeAtLocation
}

// SV: Anger om PlaneradBeraknadTid är giltig. Kommer sättas till false när en operativ beräknad tidrapport, tidrapport eller slopningsrapport skapas
func (x *TrainAnnouncement) PlannedEstimatedTimeAtLocationIsValid() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.PlannedEstimatedTimeAtLocationIsValid
}

// SV: Kod för beskrivning av tåget och beskrivning av tåget, ex. "Tågkompaniet", "SJ InterCity", "TiB/Tågkomp"
func (x *TrainAnnouncement) ProductInformation() []ProductInformation {
	data := []ProductInformation{}
	for _, mem := range x.data.ProductInformation {
		data = append(data, ProductInformation{data: &mem})
	}
	return data
}

// SV: Tågets annonserade avgångsdatum
func (x *TrainAnnouncement) ScheduledDepartureDateTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ScheduledDepartureDateTime
}

// SV: Servicekod och lite extra utöver produktinformation, ex "Bistro", "Sov-och liggv"
func (x *TrainAnnouncement) Services() []Service {
	data := []Service{}
	for _, mem := range x.data.Service {
		data = append(data, Service{data: &mem})
	}
	return data
}

// SV: När tåget har ankommit eller avgått
func (x *TrainAnnouncement) TimeAtLocation() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.TimeAtLocation
}

// SV: När tåget har ankommit eller avgått, med sekunder
func (x *TrainAnnouncement) TimeAtLocationWithSeconds() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.TimeAtLocationWithSeconds
}

// SV: Till station för tåget med ordning och i vilken prioritet som ska visas. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. ToLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur till-stationer ska annonseras.
func (x *TrainAnnouncement) ToLocations() []ToLocation {
	data := []ToLocation{}
	for _, mem := range x.data.ToLocation {
		data = append(data, ToLocation{data: &mem})
	}
	return data
}

// SV: Spår
func (x *TrainAnnouncement) TrackAtLocation() *string {
	if x.data == nil {
		return nil
	}
	return x.data.TrackAtLocation
}

// SV: Kod för tågsammansättning och tågsammansättning, ex: "Vagnsordning 7, 6, 5, 4, 2, 1"
func (x *TrainAnnouncement) TrainCompositions() []TrainComposition {
	data := []TrainComposition{}
	for _, mem := range x.data.TrainComposition {
		data = append(data, TrainComposition{data: &mem})
	}
	return data
}

// SV: Ägaren av det aktuella tågläget
func (x *TrainAnnouncement) TrainOwner() *string {
	if x.data == nil {
		return nil
	}
	return x.data.TrainOwner
}

// SV: Trafiktypen, ex. "Buss", "Pendeltåg", "Taxi", "Tåg".
func (x *TrainAnnouncement) TypesOfTraffic() []TypeOfTraffic {
	data := []TypeOfTraffic{}
	for _, mem := range x.data.TypeOfTraffic {
		data = append(data, TypeOfTraffic{data: &mem})
	}
	return data
}

func (x *TrainAnnouncement) ViaFromLocations() []ViaFromLocation {
	data := []ViaFromLocation{}
	for _, mem := range x.data.ViaFromLocation {
		data = append(data, ViaFromLocation{data: &mem})
	}
	return data
}

func (x *TrainAnnouncement) ViaToLocations() []ViaToLocation {
	data := []ViaToLocation{}
	for _, mem := range x.data.ViaToLocation {
		data = append(data, ViaToLocation{data: &mem})
	}
	return data
}

// SV: Url till trafikägarens hemsida
func (x *TrainAnnouncement) WebLink() *string {
	if x.data == nil {
		return nil
	}
	return x.data.WebLink
}

// SV: Namn på trafikinfoägaren att använda i länkar
func (x *TrainAnnouncement) WebLinkName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.WebLinkName
}

type Booking struct {
	data *schema.Booking
}

func (x *Booking) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Booking{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för bokningsinformation
func (x *Booking) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som ger bokningsinformation, ex: "Vagn 4 obokad", "Platsbiljett krävs"
func (x *Booking) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type Deviation struct {
	data *schema.Deviation
}

func (x *Deviation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Deviation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för avvikelse
func (x *Deviation) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som beskriver avvikelse, ex: "Buss ersätter", "Spårändrat", "Kort tåg", "Ej servering", "Oväder"
func (x *Deviation) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type FromLocation struct {
	data *schema.FromLocation
}

func (x *FromLocation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.FromLocation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Namn på frånstation. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. FromLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur från-stationer ska annonseras.
func (x *FromLocation) LocationName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationName
}

// SV: Prioritet för vilka stationer som ska visas.
func (x *FromLocation) Priority() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Priority
}

// SV: Vilken ordning stationer ska visas.
func (x *FromLocation) Order() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Order
}

type OtherInformation struct {
	data *schema.OtherInformation
}

func (x *OtherInformation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.OtherInformation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för övrig annonseringsinformation
func (x *OtherInformation) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som ger övrig annonseringinformation, ex. "Trevlig resa!", "Bakre vagnen låst!", "Ingen påstigning"
func (x *OtherInformation) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type ProductInformation struct {
	data *schema.ProductInformation
}

func (x *ProductInformation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ProductInformation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för produkten
func (x *ProductInformation) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som beskriver produkten, ex. "Västtågen", "SJ Snabbtåg", "Pågatågen"
func (x *ProductInformation) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type Service struct {
	data *schema.Service
}

func (x *Service) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Service{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för service
func (x *Service) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som beskriver den service som finns, ex "Bistro", "Sov-och liggvagnar", "Kiosk"
func (x *Service) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type ToLocation struct {
	data *schema.ToLocation
}

func (x *ToLocation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ToLocation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Tillstation för tåget. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. ToLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur till-stationer ska annonseras.
func (x *ToLocation) LocationName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationName
}

// SV: Prioritet för vilka stationer som ska visas.
func (x *ToLocation) Priority() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Priority
}

// SV: Vilken ordning stationer ska visas.
func (x *ToLocation) Order() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Order
}

type TrainComposition struct {
	data *schema.TrainComposition
}

func (x *TrainComposition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TrainComposition{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för tågsammansättning
func (x *TrainComposition) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som beskriver tågsammansättning, ex: "Vagnsordning 7, 6, 5, 4, 2, 1"
func (x *TrainComposition) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type TypeOfTraffic struct {
	data *schema.TypeOfTraffic
}

func (x *TypeOfTraffic) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TypeOfTraffic{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för trafiktyp
func (x *TypeOfTraffic) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Trafiktypen, ex. "Buss", "Pendeltåg", "Taxi", "Tåg".
func (x *TypeOfTraffic) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type ViaFromLocation struct {
	data *schema.ViaFromLocation
}

func (x *ViaFromLocation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ViaFromLocation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Namn på via frånstation. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. ViaFromLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur från-stationer ska annonseras.
func (x *ViaFromLocation) LocationName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationName
}

// SV: Prioritet för vilka stationer som ska visas.
func (x *ViaFromLocation) Priority() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Priority
}

// SV: Vilken ordning stationer ska visas.
func (x *ViaFromLocation) Order() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Order
}

type ViaToLocation struct {
	data *schema.ViaToLocation
}

func (x *ViaToLocation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ViaToLocation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Namn på vi. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. ViaToLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur till-stationer ska annonseras.
func (x *ViaToLocation) LocationName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationName
}

// SV: Prioritet för vilka stationer som ska visas.
func (x *ViaToLocation) Priority() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Priority
}

// SV: Vilken ordning stationer ska visas.
func (x *ViaToLocation) Order() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Order
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "code.dny.dev/trafikinfo/trv/trainannouncement/v1dot9"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError       `xml:"ERROR"`
		Data  []TrainAnnouncement `xml:"TrainAnnouncement"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
