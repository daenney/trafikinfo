// Package v1 contains the type definitions for RoadData v1.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1

import (
	"encoding/xml"
	"strings"
	"time"

	schema "code.dny.dev/trafikinfo/internal/trv/roaddata/v1"
	"code.dny.dev/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func ObjectType() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "RoadData",
		Version:   "1",
		Namespace: "",
	}
}

type RoadData struct {
	data *schema.RoadData
}

func (x *RoadData) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadData{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Län.
func (x *RoadData) County() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.County
}

// SV: Huvudvägnummer.
func (x *RoadData) RoadMainNumber() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.RoadMainNumber
}

// SV: Undervägnummer. Kallas ibland även punktväg. Måste användas ihop med huvudvägnumret.
func (x *RoadData) RoadSubNumber() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.RoadSubNumber
}

func (x *RoadData) Direction() *Direction {
	if x.data == nil {
		return new(Direction)
	}
	return &Direction{data: x.data.Direction}
}

// SV: Körfältsbeskrivning. Beskrivning av körfältskombinationer, främst för att utskilja vilka vägar som har s.k. 2+1 körfältsuppdelning.
func (x *RoadData) LaneDescription() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.LaneDescription
}

// SV: Start löpande längd. Anges i meter. Starten för aktuell data angivet i antal meter från vägnumrets start inom det länet, i aktuell riktning.
func (x *RoadData) StartContinuousLength() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.StartContinuousLength
}

// SV: Slut löpande längd. Anges i meter. Slutet för aktuell data angivet i antal meter från vägnumrets start inom det länet, i aktuell riktning.
func (x *RoadData) EndContinuousLength() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.EndContinuousLength
}

// SV: Längd.
func (x *RoadData) Length() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.Length
}

func (x *RoadData) BearingCapacity() *BearingCapacity {
	if x.data == nil {
		return new(BearingCapacity)
	}
	return &BearingCapacity{data: x.data.BearingCapacity}
}

// SV: Hastighetsgräns. Skyltad hastighet. Vid variabel hastighet visar pmsv3 1000 km/h för att markera att hastigheten inte är entydig.
func (x *RoadData) SpeedLimit() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.SpeedLimit
}

// SV: Slitlager
func (x *RoadData) WearLayer() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.WearLayer
}

// SV: ÅDT fordon. På mötesseparerad väg anges ÅDT för en riktning i taget. Dvs. den siffra som anges är trafiken i en riktning. På vanlig väg, dvs där trafiken går i båda riktningar, utan mittseparering, gäller ÅDT-siffran båda riktningar tillsammans. Om det finns fler än ett körfält gäller angivna ÅDT-siffran för alla körfält tillsammans. T.ex: Om ÅDT = 20000 fordon och det finns 3 körfält, så kommer ÅDT att anges som 20000 för varje körfält.
func (x *RoadData) AADT() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.AADT
}

// SV: ÅDT tung. ÅDT lastbilar avser trafikflöde lastbilar. (Antal lastbilar per årsmedeldygn).
func (x *RoadData) AADTHeavyVehicles() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.AADTHeavyVehicles
}

// SV: ÅDT mätår.
func (x *RoadData) AADTMeasurementYear() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.AADTMeasurementYear
}

func (x *RoadData) AADTMeasurementMethod() *AADTMeasurementMethod {
	if x.data == nil {
		return new(AADTMeasurementMethod)
	}
	return &AADTMeasurementMethod{data: x.data.AADTMeasurementMethod}
}

// SV: Vägbredd.
func (x *RoadData) RoadWidth() float64 {
	if x.data == nil {
		return *new(float64)
	}
	return x.data.RoadWidth
}

func (x *RoadData) RoadOwner() *RoadOwner {
	if x.data == nil {
		return new(RoadOwner)
	}
	return &RoadOwner{data: x.data.RoadOwner}
}

func (x *RoadData) RoadCategory() *RoadCategory {
	if x.data == nil {
		return new(RoadCategory)
	}
	return &RoadCategory{data: x.data.RoadCategory}
}

func (x *RoadData) RoadType() *RoadType {
	if x.data == nil {
		return new(RoadType)
	}
	return &RoadType{data: x.data.RoadType}
}

func (x *RoadData) Winter2003() *Winter2003 {
	if x.data == nil {
		return new(Winter2003)
	}
	return &Winter2003{data: x.data.Winter2003}
}

// SV: Vägnybyggnadsår 2009. Det årtal som en nybyggnad utförts på vägen, vägsträckan byggdes, och det årtal som ett förstärkningsarbete utförts på en vägsträcka.
func (x *RoadData) RoadConstruction2009() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.RoadConstruction2009
}

// SV: Datum för när vägdata hämtades ut från källsystemet.
func (x *RoadData) TimeStamp() time.Time {
	if x.data == nil {
		return *new(time.Time)
	}
	return x.data.TimeStamp
}

// SV: Tidpunkt då dataposten ändrades
// EN: Time when the data item was changed
func (x *RoadData) ModifiedTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ModifiedTime
}

// SV: Anger att dataposten raderats
// EN: Indicates that the data record has been deleted
func (x *RoadData) Deleted() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Deleted
}

type Direction struct {
	data *schema.Direction
}

func (x *Direction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Direction{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Riktning. Värde.
func (x *Direction) Code() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.Code
}

// SV: Riktning. Beskrivning.
func (x *Direction) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type BearingCapacity struct {
	data *schema.BearingCapacity
}

func (x *BearingCapacity) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.BearingCapacity{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Bärighetsklass. Upplåten bärighetsklass på statliga och kommunala vägar. Värde.
func (x *BearingCapacity) Code() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.Code
}

// SV: Bärighetsklass. Upplåten bärighetsklass på statliga och kommunala vägar. Beskrivning.
func (x *BearingCapacity) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type AADTMeasurementMethod struct {
	data *schema.AADTMeasurementMethod
}

func (x *AADTMeasurementMethod) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.AADTMeasurementMethod{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: ÅDT mätmetod. värde.
func (x *AADTMeasurementMethod) Code() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.Code
}

// SV: ÅDT mätmetod. beskrivning.
func (x *AADTMeasurementMethod) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type RoadOwner struct {
	data *schema.RoadOwner
}

func (x *RoadOwner) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadOwner{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Väghållare. Den som är ansvarig för väghållningen.
func (x *RoadOwner) Code() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.Code
}

// SV: Väghållare. Den som är ansvarig för väghållningen. Beskrivning.
func (x *RoadOwner) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type RoadCategory struct {
	data *schema.RoadCategory
}

func (x *RoadCategory) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadCategory{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Vägkategori. Värde.
func (x *RoadCategory) Code() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.Code
}

// SV: Vägkategori. Beskrivning.
func (x *RoadCategory) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type RoadType struct {
	data *schema.RoadType
}

func (x *RoadType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadType{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Vägtyp. Värde.
func (x *RoadType) Code() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.Code
}

// SV: Vägtyp. Beskrivning.
func (x *RoadType) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type Winter2003 struct {
	data *schema.Winter2003
}

func (x *Winter2003) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Winter2003{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Vinter2003. Vinter2003/Klassificering map vinterväghållningstandard. Värde.
func (x *Winter2003) Code() int {
	if x.data == nil {
		return *new(int)
	}
	return x.data.Code
}

// SV: Vinter2003. Vinter2003/Klassificering map vinterväghållningstandard. Beskrivning.
func (x *Winter2003) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "code.dny.dev/trafikinfo/trv/roaddata/v1"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError `xml:"ERROR"`
		Data  []RoadData    `xml:"RoadData"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
