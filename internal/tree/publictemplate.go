package tree

import (
	"fmt"
	"io"
	"strings"
)

const publicPremble = `// Package %s contains the type definitions for %s v%s.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package %s

import (
	"encoding/xml"
	"strings"
	"time"

	schema "code.dny.dev/trafikinfo/internal/trv/%s/%s"
	"code.dny.dev/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func ObjectType() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "%s",
		Version:   "%s",
		Namespace: "%s",
	}
}

`

const publicEpilogue = `// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "code.dny.dev/trafikinfo/trv/%s/%s"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name ` + "`xml:\"RESPONSE\"`" + `
	Results []struct {
		Info struct {
			LastModified trv.LastModified ` + "`xml:\"LASTMODIFIED\"`" + `
			LastChangeID string           ` + "`xml:\"LASTCHANGEID\"`" + `
			EvalResult   []any            ` + "`xml:\"EVALRESULT\"`" + `
			SSEURL       string           ` + "`xml:\"SSEURL\"`" + `
		} ` + "`xml:\"INFO\"`" + `
		Error *trv.APIError ` + "`xml:\"ERROR\"`" + `
		Data  []%s      ` + "`xml:\"%s\"`" + `
	} ` + "`xml:\"RESULT\"`" + `
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}

`

const publicStruct = `type %s struct {
	data *schema.%s
}

func (x *%s) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.%s{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

`

func (r *Root) PublicTemplate(w io.Writer) {
	io.WriteString(w, fmt.Sprintf(
		publicPremble,
		r.Meta.PackageVersion(),
		r.Meta.Name,
		r.Meta.Version,
		r.Meta.PackageVersion(),
		strings.ToLower(r.Meta.Name),
		r.Meta.PackageVersion(),
		r.Meta.Name,
		r.Meta.Version,
		r.Meta.Namespace,
	))

	for _, node := range r.Nodes {
		node.PublicRender(w, "")
	}

	io.WriteString(w, fmt.Sprintf(
		publicEpilogue,
		strings.ToLower(r.Meta.Name),
		r.Meta.PackageVersion(),
		r.Meta.Name,
		r.Meta.Name,
	))
}

func (n *Node) PublicRender(w io.Writer, name string) {
	if len(n.Documentation) > 0 {
		io.WriteString(w, strings.Join(n.Documentation, "\n"))
		io.WriteString(w, "\n")
	}

	if name != "" {
		n.PublicRenderMethod(w, name)
		return
	}

	io.WriteString(w, fmt.Sprintf(
		publicStruct,
		n.Name,
		n.Name,
		n.Name,
		n.Name,
	))

	for _, nd := range n.Nodes {
		nd.PublicRender(w, n.Name)
	}
}

func (n *Node) PublicRenderMethod(w io.Writer, name string) {
	io.WriteString(w, "func (x *"+name+") "+goIdentifier(n.Name, n.Multiple)+"() ")
	if n.Optional {
		io.WriteString(w, "*")
	}
	if n.Multiple {
		io.WriteString(w, "[]")
	}
	io.WriteString(w, n.Type.Kind+" {\n")
	if n.Type.Final {
		io.WriteString(w, "return x.data."+goName(n.Name)+"\n")
	} else {
		if n.Multiple {
			io.WriteString(w, "data := []"+n.Type.Kind+"{}\n")
			io.WriteString(w, "for _, mem := range x.data."+n.Name+"{\n")
			io.WriteString(w, "data = append(data, "+n.Type.Kind+"{data: &mem})\n")
			io.WriteString(w, "}\n")
			io.WriteString(w, "return data\n")
		} else {
			io.WriteString(w, "return ")
			if n.Optional {
				io.WriteString(w, "&")
			}
			io.WriteString(w, n.Type.Kind+"{data: ")
			if !n.Optional {
				io.WriteString(w, "&")
			}
			io.WriteString(w, "x.data.")
			io.WriteString(w, n.Name+"}\n")
		}
	}
	io.WriteString(w, "}\n\n")
}
